/*
 * Copyright (c) 2025, Marc Himmelberger <marc dot himmelberger at inf dot ethz dot ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package encoding_kemeleon

import (
	"bytes"
	"encoding/hex"
	"flag"
	"os"
	"slices"
	"testing"

	"gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/lyrebird/internal/cryptodata"
	"gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/lyrebird/internal/cryptofactory/oqs_wrapper"
	"gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/lyrebird/internal/kems"
)

var parameterSets = []string{
	"ML-KEM-512",
	"ML-KEM-768",
	"ML-KEM-1024",
}

const minSuccessRate = float32(1.0)            // encoding should never reject
const minLooksOkRate = float32(0.96875 - 0.05) // 2^-5 probability of all padding bits being 0 and some margin

// Number of times to repeat correctness tests for applicable KEMs.
var numRepeats int

func TestMain(m *testing.M) {
	flag.Parse()
	if testing.Short() {
		numRepeats = 10
	} else {
		numRepeats = 100
	}
	code := m.Run()
	os.Exit(code)
}

func TestEncoding(t *testing.T) {
	for _, kemName := range parameterSets {
		t.Run(kemName, func(t *testing.T) {
			encodingOkNum := 0
			looksOkNum := 0
			for range numRepeats {
				encodingOk, looksOk := testSingleKemEncoding(t, kemName)
				if encodingOk {
					encodingOkNum++
					if looksOk {
						looksOkNum++
					}
				}
			}

			successRate := float32(encodingOkNum) / float32(numRepeats)
			looksOkRate := float32(looksOkNum) / float32(encodingOkNum)
			if successRate < minSuccessRate {
				t.Fatalf("Success Rate of %f too low. Minimum: %f", successRate, minSuccessRate)
			}
			t.Logf("Success Rate of %f acceptable. Minimum: %f", successRate, minSuccessRate)
			if looksOkRate < minLooksOkRate {
				t.Fatalf("Looks-OK Rate of %f too low. Minimum: %f", looksOkRate, minLooksOkRate)
			}
			t.Logf("Looks-OK Rate of %f acceptable. Minimum: %f", looksOkRate, minLooksOkRate)
		})
	}
}

func testSingleKemEncoding(t *testing.T, kemName string) (ok bool, looksOk bool) {
	kem := (kems.KeyEncapsulationMechanism)(oqs_wrapper.NewOqsWrapper(kemName))
	encoder := &KemeleonEncoder{}

	encoder.Init(kem)

	// Specific to Kemeleon: Check KEM output size
	if kem.LengthCiphertext() != encoder.kemCtxtLength {
		panic("encoding_mlkem_kemeleon: Received invalid ciphertext size from KEM")
	}

	// KeyGen, Encaps
	keypair := kem.KeyGen()
	ctxt, _, _ := kem.Encaps(keypair.Public())

	// Specific to Kemeleon: Check layout of ctxt
	// TODO
	if 0 != 0 {
		t.Fatalf("KEM ciphertext looks somehow bad")
	}

	// EncodeCtxt
	encodedCtxt := make([]byte, encoder.LengthObfuscatedCiphertext())
	ok = encoder.EncodeCiphertext(encodedCtxt, ctxt.Bytes())
	if !ok {
		t.Log("encoder.EncodeCiphertext(ctxt) failed")
		return
	}

	// Specific to Kemeleon: Check layout of encodedCtxt
	// TODO
	if 0 != 0 {
		t.Log("Encoded ciphertext looks somehow bad")
		looksOk = false
	} else {
		looksOk = true
	}

	// DecodeCtxt
	decodedCtxt := make([]byte, kem.LengthCiphertext())
	encoder.DecodeCiphertext(decodedCtxt, encodedCtxt)
	if !bytes.Equal(ctxt.Bytes(), decodedCtxt) {
		t.Fatalf("correctness violation in encoding: expected %x, actual: %x", ctxt.Bytes(), decodedCtxt)
	}

	return
}
func fromHex(t *testing.T, hexString string) []byte {
	val, err := hex.DecodeString(hexString)
	if err != nil {
		t.Fatalf("hex.DecodeString() failed for value '%s'. The error was: %v", hexString, err)
	}
	return val
}

func TestWithTestVectors(t *testing.T) {
	// Test vectors from https://github.com/C2SP/CCTV/blob/main/ML-KEM/intermediate/ML-KEM-1024.txt
	kemName := "ML-KEM-1024"

	kem := (kems.KeyEncapsulationMechanism)(oqs_wrapper.NewOqsWrapper(kemName))
	encoder := &KemeleonEncoder{}

	encoder.Init(kem)

	// Specific to Kemeleon: Check KEM output size
	if kem.LengthCiphertext() != encoder.kemCtxtLength {
		panic("Received invalid ciphertext size from KEM")
	}

	// KeyGen: Use ek, dk from test vectors
	ek := fromHex(t, "ed859032bbb74c7412a7271c8ef23a5a08c31551a2a5cb8ada78538ce6c96d11625cb45e87b133163b16a4705aba1514f006afccbccf3c5c05acbc4563771bb8508072745d0ba56f57566181c3073b6c2b0dda50a2a83e74c67bcd48c0820b809d03a6ae4193dbd3bc06d072d2c64fd1e0b408a9c29818cd2df7790f9779536b0a076b4fb57b56f8cbb8ea3290c2f8b381c993d9eb49d8b4873ec660895528ab9ac306a66ae8209e2db9b79cb89220fab9d5cbb290ac690c79199218229aa8276393a73c826459429baed8365b88733871450e9523959c3f28691a3a0622e923259d2c90a61ca1525caf75a3a4292036957a5966d55840927234e1c5445b6685396890e3ccb9869147e63ce0b23defbb1c00f46df3819dd4a5756a355f61c1793b25a9b713c3abd12605198083773cf26909ffc92cd423cd290ba1801c694e7c80d6e2c9c1b943c69a5e7387ade187b21bd2a598c49ec772cde74656f1b43fa21021bcb86db8f91e03522bb4a76823483033f68659b57fa972c42673795b9a5dafa229fd8818f940a1b38a925cf06af712332b789a6f64ce91c7010af8a531101de8541a3ba4b4b893bfe7e791e693a5987a3d2d7224aeb213c5aba14aa0686efbbf31258d37122c304151916a9291181ffe788864f52acf001d788a3d80e4ad14623e9c402090b73fae5cb4225802cc4ab9c323c8cb914231c31c14c12a20ab7b5df5b6815bc04d991a32b6ccd229cf9692bf2e549ceb66512be58afe284b1d4990e46b5bafcca72589024e0b710169445e793cbbda9ca2664882199a54c31484d9364c2545876758999027c8f6423fa1a9ea810731092ca41c2451f29452c24d1d120517e06eaac91a77a47dec3c036ff84bfda92bcb396a36a75007014c0b6882a939b7e2c109c6046c04e9c1e4b1bd83444cf7838ca909946b512cb8d06ed3ab66a62071eb439632cccbced23c06c3456cdabf321328a17263e6aa3fee0028bef312cc99477ac71c53909740502e340b7cc06111eeb90bb08c58bfb97d78acbb10e7240ee5672062783636565c1744217787ffa33287f5075464b97707aec6864b38c918e0ebaf40fc9aac6128db4863a40c80b9d23261344a370c7b2dcb76e38623e5443242bcce9fb872b4c589b886aeb9fc79347cbf216b6ea8d1c7f5c5802fa24d1e68a4dc161699f90681069898e41d34a82cced119189b6547587972c4b17851a292f728f638a90164b97416c5b5b9231f1c675cf12c8ec1ce4866673f61addf98950263680efb56124b5936862f5328a3de923c4b2435b543ceee3b9761b5515aaaaecbdbb9cf8202090c82a2e5301fd0aee4fa4b39b0302d1813ab87cc1ba15595c36ef953401a92b8a88465c29ca4062626bc45b2a762c4ed957e53551827322351701db42c73e340566a476f559ac776283816da810c76af10f41482577544302e80eb6ab2fb720c2a950464c62970a450e65983c336dde77039722c614143a2b72c40256cf2142365ebaf288b0d9d69b56671b45f72c90a26ad50229d8fd6291ae6306d614aba34b65af02fa7cc2f5d7c5c8f4b30dc715f65f82c6320088fe0cfd4f05dc63a22ffeb0f38f68c5e08af5603c605007c9efc1f1574c94d322191f248cf34246d9bb06c650e85a8ce1832860689af7791054bd01b79a11cc41ca05f3a174d9393191bc541678989b0a6fbea82c488aa828b077003a69b335098d00616e28d7853ab98b54c0b99840ff94393532285ccbc003120cd8b77c5c18d0e654750893de5c071a60a152350cc537a34a60c7032c21623c1bd0ce38046b986e786051e9891a7784223b45cc09682dbfacd92776f594377d07290667a81726c7a62ab1e883329b22205b3e72165c846261429dd3cccedd4933bb38f4b9000a066c2464844ab47899269033078c1f2473e564a2c697caeded4cda82b8516c287b23a84ee997fe9206874f73d130a73d5a14e10668365089a9695b7870806fa8431663120eac9b9133937117cb3bcf862e306747139253f181deb0352e6bb6b888561d46b3406fa31ec08520b275bacb6b1fd1bc40076958ed1bf96b70c5f567c9f83a3abdcc85e81aa0f99a50c2aac18a4177aa0bd1d7caaabb11e09a3bc211685396750a4723c8c8334433019c1844c9aa22b6e6995bc703ddb09edbe4f1a61a62a23531cf707976a861efef13e8347210d77f3d080e9ba89")
	dk := fromHex(t, "82b25c61f7099f870f988428ad662203f75c638390c593035b3aa1a91092b2d276fddb56bcab637e00a26ee68058376ad13c0e5d7b31ed29b2c24710b47b60246214bf308f8dd77379590842740c84ab6d8adc71a1cb22c4e98e58112d803998a104bd606cb439e0b686384148a209f5d171e4b63e29f66863aacba2c5a489600dfb64b65ce21f848b4c7621c6a3e65792497d1354a72e22405057cf9330332b419ca396cf69d374df850a2481c943488ab45cb71c992e12034baa94272a32cc694294ab6867d4f8758f972520ec5f90159fda33ad91d893273ac9a3e35f2976bbff525a2de84cbc55acbca91fa9ea91700abb87323d2a67c95d62cad3dc534aa83ff3fb6837ea908f0b953ca88bfb01b62068a1ade3c19e7b153f8b34b19295e054334f59b73855c030e597b688c3d2a14a336a2929393e0b27171315805e5cc3053b6d90843d82b933c1cc1574c18d9dda933f3b33b8cb7bf7143f6f595b1ec7113fd46f629930f28c4d4f666ce24bccd8bca5d74488de3b2480b176c0eb6f9dd19434ec33563303fcf7cdbe09c55d4216ad524379e451e74a2121c442c4412de5e137ed18421e07779b598860cc2e4e42c10f58a01617936c4548453183739c5624c68915b79a25a90257b1437a1583a9107d7d0587bee15570f3c008b9140f779cdce06fba05ac57991020162bb2096911594109f9032a09007eea48e1b5b5e11c9643d75284256c5a73b935668abb12aeeab7b040f71e17a74235e166d1942f7caa890869ccb1184cd44a9e82a89f31e83602e21de2b5cacfc254282470e0c66b020a5b058043e9135ab06c4fe1329d7a280ba6dc3de017c1041a26cf3b10d305c73594c469ac11b091bcb20412dfdc3ef0b712aee31fc2a81bfbd9990ca296fe45bcb992ba92d4148591a2f80990f218a2991bb3f3098a36c6568db8a40ab03b9e017305d893b48285a5178ee6b80dd2c5555837c3e976afd36b895c10acb438ca7009ad7723b31b3aa6a680156ec3cfe4e813dbf010e6e5b39a890b76984d20e965c5a39a6cda801ec55c55245abe3b946bda7c8e70c99ac62e2ca2c2ce165722d710a1c443a6467f91c63ed53c3f223580fbd058b6c8b4f134ae3b490ae97466e1983b0e669b22615df1732df9e9a98d4575720571ffa60dc888a65f6644902a9ad89a93c4b22132515d808ca445bab49e3276caa8a48d272b823477a0bc151491c229ab38bd6a4485257374cbcd03d6a6c655b6a1d06751995fa1c394116476f399673b5b40857cb9c68721168a936d89a3008923b81c2d7eb94ba63c3eff45b4ccb48a9d2142e8d5238ce904376bcd1e088b864a6a5acab75b138b9be44b08f00825bc3a804835337cac36bc41ca8bab90384a51341875c7ad27d109afa36e2965cafe1922811762a077af789b8d6c490c0f102b62869ca38a83effb05f14ac82346645de63cb60bba30b665a3f1c9f842952aea89fe630f6404b63164a39692180d806d65da3c1be076ae77b42d665edd2b93c1210427909d294a2fbad460444032a727960210005b7b3ad367cc300738187b3c64bbc00b16257f09182537129b14bf94c482bfdb9b82634821862a7fb0234ae0b5685582de054cb5575e9f8464336609cbd7ad5b486117ac4ea2468be9147e8c96b3a07993d5725f85c31c79405541c2c13b3abdc55b2dfa2ab02842a711a2b877097769c22be065622ab0a92d5108bfa10c644935ee4652efca95fafca3b5cccf0187a45708cf68838ffa79427a0400f8439f15b11e064b2b777c0715aa8a91c96ea7f1a851f47f8f077514a36c901059892273ca8695b3b418c8187558d18f1b9153d6c0b966e08f9a675889aa519224cdc4fc1fee51082ec26cea593124435f4bf95b3d852ad9554953088aae602e0ad3023d17576123929b1150fa496b850ab4e5f372ab7188f3127d2dcb970df56c4f5a2548903bd5ec50fb9196cf2374d7cc728243757743083d4a93c4b6adca54314a3200fe5a303aba4c07d4cf3eb632eca5b353190decd984395192d1f63d3d9291e00aa17e0872df27a405832d0a7b43115b05e6a4cb9293812ab26eb2e148e4b5082ba99039d6847a03be1693afc09a3ab95044107586e0db02720145c84cc800b669c51c8a96e526c4a99970234409414ed623cced859032bbb74c7412a7271c8ef23a5a08c31551a2a5cb8ada78538ce6c96d11625cb45e87b133163b16a4705aba1514f006afccbccf3c5c05acbc4563771bb8508072745d0ba56f57566181c3073b6c2b0dda50a2a83e74c67bcd48c0820b809d03a6ae4193dbd3bc06d072d2c64fd1e0b408a9c29818cd2df7790f9779536b0a076b4fb57b56f8cbb8ea3290c2f8b381c993d9eb49d8b4873ec660895528ab9ac306a66ae8209e2db9b79cb89220fab9d5cbb290ac690c79199218229aa8276393a73c826459429baed8365b88733871450e9523959c3f28691a3a0622e923259d2c90a61ca1525caf75a3a4292036957a5966d55840927234e1c5445b6685396890e3ccb9869147e63ce0b23defbb1c00f46df3819dd4a5756a355f61c1793b25a9b713c3abd12605198083773cf26909ffc92cd423cd290ba1801c694e7c80d6e2c9c1b943c69a5e7387ade187b21bd2a598c49ec772cde74656f1b43fa21021bcb86db8f91e03522bb4a76823483033f68659b57fa972c42673795b9a5dafa229fd8818f940a1b38a925cf06af712332b789a6f64ce91c7010af8a531101de8541a3ba4b4b893bfe7e791e693a5987a3d2d7224aeb213c5aba14aa0686efbbf31258d37122c304151916a9291181ffe788864f52acf001d788a3d80e4ad14623e9c402090b73fae5cb4225802cc4ab9c323c8cb914231c31c14c12a20ab7b5df5b6815bc04d991a32b6ccd229cf9692bf2e549ceb66512be58afe284b1d4990e46b5bafcca72589024e0b710169445e793cbbda9ca2664882199a54c31484d9364c2545876758999027c8f6423fa1a9ea810731092ca41c2451f29452c24d1d120517e06eaac91a77a47dec3c036ff84bfda92bcb396a36a75007014c0b6882a939b7e2c109c6046c04e9c1e4b1bd83444cf7838ca909946b512cb8d06ed3ab66a62071eb439632cccbced23c06c3456cdabf321328a17263e6aa3fee0028bef312cc99477ac71c53909740502e340b7cc06111eeb90bb08c58bfb97d78acbb10e7240ee5672062783636565c1744217787ffa33287f5075464b97707aec6864b38c918e0ebaf40fc9aac6128db4863a40c80b9d23261344a370c7b2dcb76e38623e5443242bcce9fb872b4c589b886aeb9fc79347cbf216b6ea8d1c7f5c5802fa24d1e68a4dc161699f90681069898e41d34a82cced119189b6547587972c4b17851a292f728f638a90164b97416c5b5b9231f1c675cf12c8ec1ce4866673f61addf98950263680efb56124b5936862f5328a3de923c4b2435b543ceee3b9761b5515aaaaecbdbb9cf8202090c82a2e5301fd0aee4fa4b39b0302d1813ab87cc1ba15595c36ef953401a92b8a88465c29ca4062626bc45b2a762c4ed957e53551827322351701db42c73e340566a476f559ac776283816da810c76af10f41482577544302e80eb6ab2fb720c2a950464c62970a450e65983c336dde77039722c614143a2b72c40256cf2142365ebaf288b0d9d69b56671b45f72c90a26ad50229d8fd6291ae6306d614aba34b65af02fa7cc2f5d7c5c8f4b30dc715f65f82c6320088fe0cfd4f05dc63a22ffeb0f38f68c5e08af5603c605007c9efc1f1574c94d322191f248cf34246d9bb06c650e85a8ce1832860689af7791054bd01b79a11cc41ca05f3a174d9393191bc541678989b0a6fbea82c488aa828b077003a69b335098d00616e28d7853ab98b54c0b99840ff94393532285ccbc003120cd8b77c5c18d0e654750893de5c071a60a152350cc537a34a60c7032c21623c1bd0ce38046b986e786051e9891a7784223b45cc09682dbfacd92776f594377d07290667a81726c7a62ab1e883329b22205b3e72165c846261429dd3cccedd4933bb38f4b9000a066c2464844ab47899269033078c1f2473e564a2c697caeded4cda82b8516c287b23a84ee997fe9206874f73d130a73d5a14e10668365089a9695b7870806fa8431663120eac9b9133937117cb3bcf862e306747139253f181deb0352e6bb6b888561d46b3406fa31ec08520b275bacb6b1fd1bc40076958ed1bf96b70c5f567c9f83a3abdcc85e81aa0f99a50c2aac18a4177aa0bd1d7caaabb11e09a3bc211685396750a4723c8c8334433019c1844c9aa22b6e6995bc703ddb09edbe4f1a61a62a23531cf707976a861efef13e8347210d77f3d080e9ba89fa12bd4f75caa74f23b4af606902f6187dd9be62a43b1b529344f1114e69391d5f574ef7f013d4336801fed022178c3ed91d0b6d51325315fc1dcabf4770a2ea")

	keypair := kems.KeypairFromBytes(dk, ek, kem.LengthPrivateKey(), kem.LengthPublicKey())

	// Encaps: Use K and c = c1 || c2 from test vectors
	ctxt := fromHex(t, "87bd17e107d5e37b7d67c45df2453f04e778cfb38c425da461d52be742d7f53eca92a84fa0752f78c062b63bf7f67cb281c243a1ecaf67aead78868b20a9d6c3567b32782143ce00616aa573b1e01153702f8bab17513ba24a3b777dba87f026d92e960b75ab084b2f2f549d532b4016a9ec7fe9494d9aa5907c854c20f993eafff4221d7688f6a188c6a70bf794d76f62df8d350e122028d6038f76ac91d0c4814fa1ba1fa4c8dd42e9f4d733aa3b9a52a4d1b1241962986d64e28b62ae149de34d96de819b64441af85e044d894b17bb3f69d72cee5e698260af9312a03967f0b82cb24b01828730b17f5ebd2bc76d510e0fc0b00bfe814fe9a7ee4c430b803109fb6ac0454ddf65931e9745542bb02ab1620ebf8968426c6425599419f9dcb814f9c302146778baf342df8922de9e229d9af6a4113143211597da785d11a874f3c90bf1733f331a5e3348355863e45a0f0661076e4e2d5cda109fe370e64fedfaeee5d3ea0131d7b8bf3a6344abf7dcc77699f4325c6f0e9aaa8b4bfae413e22c5ea945b5d59b417c733780d03069f169be61813c15391f2dd1619cd93357ceadf8688e97b37e162a19335e3e17c676e540a0646a50f0c88357dad7e868ac1570e0ec068bce9b87e1de6c3e03098f77ee87854d97e20cf9e1bc15d9ce1833814a9f15667d8f61396bfdaf0132211ba1e639f65a4a7735e6edf3b6355f586e7434a5ffba59f7790c091c806debd0921d64d3360cf8eb42aa6238924865dbe79b50552317752633b44e1f64ebeab992225c395010a91d0966ca3b5356d2023489c38fbab20582a6cf6ba5d946e97a090da7496f8ab2e197f3a2113893980d6c48bcf834536b255ff6520350638e563b049ade5243a6c7210e56d8873f96ad5a2a8d527d4598255b7f5d5d663e8e18917f2ffa7fca37a5e0917c8a2343446b3587345ca13c78c29e813455744b8037a3c6da691087f9cd3b3bb64b948eba4eddf7d0dbcff1d31b2759e0c82d36b56e3ea3c0d21fe7d19855ff5632cdeeea2c78a5bdea96263445c653e4a12447d4c1200240ad537875571d4bf88dcc40b35437942b85aedeb211969551a9ff863704d6d9f097858ff2da1d3525aeb656a908819d0438ebb16eb81b10087f3c0d9c036a59bf3ee15579f85f1ecb16ecbf807167548635401ab6c1ca6c1edb6eed3c1efe0d2eaad683ccbfc89aa7c4dea656983cc0b959445f92c596011667e83528a964ba4a067991e745372bc05792958ed2f776b57ec98f8181e2caf7b542999c04dea5075247e70fa43ceae837fc9b3a9354668309cfbffe0194937c7064e03ad6c756c5b3e4bb0c514018d31b7084db418f105b48ba93b86095591df4157aaa82f9c186e54181e6966751ce26a6f8357b61000944218bc69c309f720a35cff5dfd27bad2197000c3f9ccb97bd00049a4a66bbc18105026430fab2aac0713534473cf1f46cf92d31f3129eeb95772f2c3ad5590210a3fcbd6603cd7420fca5fb5516629edf73d86ef03899f279d3b8f1962a71dc0d3702cb164bacac3414e9f4736992ac8fe2afeffeca9d6dfb0af61901adf9b210afcb2a1e990cd9bbba5b90ed1e230f9e39b1888ccd8fd9e1b5c37bfbf802fd6d90adfa632ec26f90cd0f4d7ab3859ef964d726851c4d2b120d154c86ac60a05918a9b0381f4cdad739261d43ce4e79de1f4fbaf09cbb3dc329303bb03af964fbd45c0b1e801530293e39754ff36c5681395931b0bff4896cb3ece79c531c72597de5451a1c56448cc25d2aacc9f1404b6440f6eb10567b0965d8d18a0368ba4d1723359130fadc83f80848c23274e7cdfcaf97ee63750cb206e25caf8b0b8b2cf066c2ccd61d844873d912109e28ee334f71eeba2d3cdc31d93415e55e82362119f81cef055694d869bff6e0d70e1ed69834b9fd40768611e1d88be19bd77d946f4910c0564b1ce0ccf0e53a45b8f065d8ec2023f226f20928f351971d3e9fa566626f295ff96c21f0d113de8e81c502d6553ddc41652271e41215f6bf3a6e0a26d284ad504b3c4fae26995b644789a262e8db27a0b41c21b82194d6ed1c4cd6ac97355b83e3f7e4f8656d33761f4bef98bfd50f1d03178b6a5be67bc1ea79dff6a7cd673dc10f63900631fd6052e0f4deedbc21dc87ca42554047ac78dba3aa4ccaae14e5eae6c1ded7990cb44b72b971e43882329347888957446a75")
	sharedSecret1 := fromHex(t, "6c4f4a231255a8cdfb7424c8dabf3a624cefaffd28964efe220ab6178fa6b324")

	// Decaps
	cd, err := cryptodata.New(ctxt, kem.LengthCiphertext())
	if err != nil {
		t.Fatal("cryptodata.New(ctxt) failed:", err)
	}
	sharedSecret2, err := kem.Decaps(keypair.Private(), kems.Ciphertext(cd))
	if err != nil {
		t.Fatal("kem.Decaps(sk, c) failed:", err)
	}
	if !bytes.Equal(sharedSecret1, sharedSecret2.Bytes()) {
		t.Fatalf("test vector on sharedSecret: expected %x, actual: %x", sharedSecret1, sharedSecret2.Bytes())
	}

	// Now that we checked that OQS can handle this test, we can dissect the bytestrings into components using our code
	c1Known := fromHex(t, "87bd17e107d5e37b7d67c45df2453f04e778cfb38c425da461d52be742d7f53eca92a84fa0752f78c062b63bf7f67cb281c243a1ecaf67aead78868b20a9d6c3567b32782143ce00616aa573b1e01153702f8bab17513ba24a3b777dba87f026d92e960b75ab084b2f2f549d532b4016a9ec7fe9494d9aa5907c854c20f993eafff4221d7688f6a188c6a70bf794d76f62df8d350e122028d6038f76ac91d0c4814fa1ba1fa4c8dd42e9f4d733aa3b9a52a4d1b1241962986d64e28b62ae149de34d96de819b64441af85e044d894b17bb3f69d72cee5e698260af9312a03967f0b82cb24b01828730b17f5ebd2bc76d510e0fc0b00bfe814fe9a7ee4c430b803109fb6ac0454ddf65931e9745542bb02ab1620ebf8968426c6425599419f9dcb814f9c302146778baf342df8922de9e229d9af6a4113143211597da785d11a874f3c90bf1733f331a5e3348355863e45a0f0661076e4e2d5cda109fe370e64fedfaeee5d3ea0131d7b8bf3a6344abf7dcc77699f4325c6f0e9aaa8b4bfae413e22c5ea945b5d59b417c733780d03069f169be61813c15391f2dd1619cd93357ceadf8688e97b37e162a19335e3e17c676e540a0646a50f0c88357dad7e868ac1570e0ec068bce9b87e1de6c3e03098f77ee87854d97e20cf9e1bc15d9ce1833814a9f15667d8f61396bfdaf0132211ba1e639f65a4a7735e6edf3b6355f586e7434a5ffba59f7790c091c806debd0921d64d3360cf8eb42aa6238924865dbe79b50552317752633b44e1f64ebeab992225c395010a91d0966ca3b5356d2023489c38fbab20582a6cf6ba5d946e97a090da7496f8ab2e197f3a2113893980d6c48bcf834536b255ff6520350638e563b049ade5243a6c7210e56d8873f96ad5a2a8d527d4598255b7f5d5d663e8e18917f2ffa7fca37a5e0917c8a2343446b3587345ca13c78c29e813455744b8037a3c6da691087f9cd3b3bb64b948eba4eddf7d0dbcff1d31b2759e0c82d36b56e3ea3c0d21fe7d19855ff5632cdeeea2c78a5bdea96263445c653e4a12447d4c1200240ad537875571d4bf88dcc40b35437942b85aedeb211969551a9ff863704d6d9f097858ff2da1d3525aeb656a908819d0438ebb16eb81b10087f3c0d9c036a59bf3ee15579f85f1ecb16ecbf807167548635401ab6c1ca6c1edb6eed3c1efe0d2eaad683ccbfc89aa7c4dea656983cc0b959445f92c596011667e83528a964ba4a067991e745372bc05792958ed2f776b57ec98f8181e2caf7b542999c04dea5075247e70fa43ceae837fc9b3a9354668309cfbffe0194937c7064e03ad6c756c5b3e4bb0c514018d31b7084db418f105b48ba93b86095591df4157aaa82f9c186e54181e6966751ce26a6f8357b61000944218bc69c309f720a35cff5dfd27bad2197000c3f9ccb97bd00049a4a66bbc18105026430fab2aac0713534473cf1f46cf92d31f3129eeb95772f2c3ad5590210a3fcbd6603cd7420fca5fb5516629edf73d86ef03899f279d3b8f1962a71dc0d3702cb164bacac3414e9f4736992ac8fe2afeffeca9d6dfb0af61901adf9b210afcb2a1e990cd9bbba5b90ed1e230f9e39b1888ccd8fd9e1b5c37bfbf802fd6d90adfa632ec26f90cd0f4d7ab3859ef964d726851c4d2b120d154c86ac60a05918a9b0381f4cdad739261d43ce4e79de1f4fbaf09cbb3dc329303bb03af964fbd45c0b1e801530293e39754ff36c5681395931b0bff4896cb3ece79c531c72597de5451a1c56448cc25d2aacc9f1404b6440f6eb10567b0965d8d18a0368ba4d1723359130fadc83f80848c23274e7cdfcaf97ee63750cb206e25caf8b0b8b2cf066c2ccd61d844873d912109e28ee334f71eeba2d3cdc31d93415e55e82362119f81cef055694d869bff6e0d70e1ed69834b9fd40768611e1d88be19bd77d946f4910c0564b1ce0ccf0e53a45b8f065d8ec2023f226f20928f351971d")
	c2Known := fromHex(t, "3e9fa566626f295ff96c21f0d113de8e81c502d6553ddc41652271e41215f6bf3a6e0a26d284ad504b3c4fae26995b644789a262e8db27a0b41c21b82194d6ed1c4cd6ac97355b83e3f7e4f8656d33761f4bef98bfd50f1d03178b6a5be67bc1ea79dff6a7cd673dc10f63900631fd6052e0f4deedbc21dc87ca42554047ac78dba3aa4ccaae14e5eae6c1ded7990cb44b72b971e43882329347888957446a75")

	// splitCtxt
	c1, c2 := encoder.splitCtxt(ctxt)
	if len(c1)+len(c2) != len(ctxt) {
		t.Fatalf("splitCtxt(ctxt) was not proper: len(c1)=%d, len(c2)=%d, len(ctxt)=%d", len(c1), len(c2), len(ctxt))
	}
	if !bytes.Equal(c1Known, c1) {
		t.Fatalf("test vector on c1: expected %x, actual: %x", c1Known, c1)
	}
	if !bytes.Equal(c2Known, c2) {
		t.Fatalf("test vector on c2: expected %x, actual: %x", c2Known, c2)
	}

	// decodeBytes
	comprUKnown := []int{1415, 759, 1924, 643, 1597, 759, 479, 1571, 605, 190, 253, 898, 1934, 1950, 812, 532, 1117, 1076, 1877, 917, 1070, 942, 1981, 1617, 146, 501, 1665, 1978, 1922, 1408, 1432, 477, 1783, 1950, 1737, 320, 1084, 322, 1019, 829, 1454, 1813, 1561, 69, 658, 1965, 1456, 986, 50, 1071, 268, 103, 1552, 724, 1257, 1419, 480, 610, 1473, 1431, 696, 559, 1748, 1297, 842, 1767, 501, 989, 1800, 589, 950, 1201, 1291, 1390, 1058, 1957, 754, 680, 1255, 346, 1600, 1314, 1970, 1215, 1182, 1178, 358, 1157, 1404, 400, 1153, 508, 1705, 511, 189, 233, 118, 1745, 647, 836, 636, 1559, 1341, 1724, 623, 1004, 1591, 1818, 288, 64, 1418, 30, 1679, 1422, 582, 616, 28, 671, 1704, 253, 164, 953, 1291, 628, 1407, 1127, 1770, 1233, 1106, 564, 711, 1170, 1569, 816, 283, 1811, 651, 1484, 1106, 462, 1246, 1324, 119, 1244, 1124, 840, 992, 559, 1232, 1810, 1490, 1496, 319, 749, 179, 1911, 1685, 260, 984, 1181, 18, 1844, 412, 1144, 715, 1892, 82, 1040, 135, 1574, 510, 1711, 699, 910, 1115, 114, 15, 1560, 46, 255, 1272, 2002, 937, 615, 835, 1, 1222, 1412, 1711, 896, 849, 1786, 869, 978, 1628, 546, 693, 1376, 1098, 789, 1806, 311, 418, 1569, 1606, 586, 1302, 204, 1273, 1819, 1106, 508, 44, 1576, 1561, 1491, 755, 1000, 551, 1809, 493, 581, 1703, 1972, 420, 1570, 1292, 656, 369, 437, 1886, 138, 1192, 1646, 1831, 133, 1855, 1662, 1676, 752, 51, 1705, 1376, 561, 1454, 1054, 65, 59, 1646, 1449, 368, 109, 497, 455, 412, 639}
	comprVKnown := []int{30, 25, 7, 11, 10, 19, 9, 12, 15, 11, 10, 30, 21, 28, 19, 13, 1, 1, 28, 3, 29, 9, 24, 27, 14, 12, 0, 11, 12, 1, 24, 26, 21, 10, 15, 24, 29, 0, 21, 12, 2, 9, 28, 8, 14, 9, 20, 2, 22, 31, 15, 21, 3, 23, 9, 1, 6, 17, 20, 9, 24, 22, 2, 10, 11, 2, 15, 30, 4, 23, 26, 4, 25, 28, 22, 8, 22, 3, 5, 17, 2, 21, 24, 16, 30, 13, 31, 4, 0, 5, 13, 25, 17, 16, 0, 23, 1, 1, 5, 13, 29, 22, 19, 3, 12, 18, 21, 25, 26, 11, 22, 6, 27, 26, 0, 7, 30, 27, 19, 28, 24, 15, 25, 26, 22, 25, 24, 14, 31, 24, 18, 30, 14, 12, 30, 23, 21, 30, 3, 26, 17, 1, 28, 2, 11, 20, 26, 22, 5, 19, 15, 15, 1, 22, 26, 19, 23, 15, 27, 30, 7, 13, 19, 15, 22, 30, 4, 24, 15, 24, 24, 0, 9, 3, 4, 6, 29, 7, 24, 4, 5, 16, 19, 30, 30, 14, 27, 25, 27, 16, 16, 27, 7, 20, 18, 5, 20, 10, 1, 8, 7, 2, 11, 17, 23, 13, 15, 20, 10, 5, 19, 20, 12, 23, 18, 2, 5, 23, 26, 13, 30, 0, 27, 27, 23, 14, 6, 25, 0, 26, 14, 9, 18, 11, 14, 3, 7, 18, 3, 7, 2, 20, 12, 6, 25, 3, 1, 17, 9, 28, 21, 8, 4, 21, 21, 14}

	comprU, comprV := encoder.decodeBytes(c1, c2)
	// test vector only considers first 256 integers for compress(u)
	if !slices.Equal(comprUKnown, comprU[:256]) {
		t.Fatalf("test vector on compress(u): expected %v, actual: %v", comprUKnown, comprU[:256])
	}
	if !slices.Equal(comprVKnown, comprV) {
		t.Fatalf("test vector on compress(v): expected %v, actual: %v", comprVKnown, comprV)
	}

	// TODO Now uncompress and check
}
